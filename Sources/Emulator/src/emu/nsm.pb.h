// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nsm.proto

#ifndef PROTOBUF_nsm_2eproto__INCLUDED
#define PROTOBUF_nsm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace nsm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_nsm_2eproto();
void protobuf_AssignDesc_nsm_2eproto();
void protobuf_ShutdownFile_nsm_2eproto();

class Attotime;
class AnalogPort;
class InputPort;
class InputState;
class PeerInputData;
class PeerInputDataList;
class InitialSync;

enum PeerInputData_PeerInputType {
  PeerInputData_PeerInputType_INPUT = 0,
  PeerInputData_PeerInputType_CHAT = 1,
  PeerInputData_PeerInputType_FORCE_VALUE = 2
};
bool PeerInputData_PeerInputType_IsValid(int value);
const PeerInputData_PeerInputType PeerInputData_PeerInputType_PeerInputType_MIN = PeerInputData_PeerInputType_INPUT;
const PeerInputData_PeerInputType PeerInputData_PeerInputType_PeerInputType_MAX = PeerInputData_PeerInputType_FORCE_VALUE;
const int PeerInputData_PeerInputType_PeerInputType_ARRAYSIZE = PeerInputData_PeerInputType_PeerInputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PeerInputData_PeerInputType_descriptor();
inline const ::std::string& PeerInputData_PeerInputType_Name(PeerInputData_PeerInputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PeerInputData_PeerInputType_descriptor(), value);
}
inline bool PeerInputData_PeerInputType_Parse(
    const ::std::string& name, PeerInputData_PeerInputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PeerInputData_PeerInputType>(
    PeerInputData_PeerInputType_descriptor(), name, value);
}
// ===================================================================

class Attotime : public ::google::protobuf::Message {
 public:
  Attotime();
  virtual ~Attotime();
  
  Attotime(const Attotime& from);
  
  inline Attotime& operator=(const Attotime& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Attotime& default_instance();
  
  void Swap(Attotime* other);
  
  // implements Message ----------------------------------------------
  
  Attotime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attotime& from);
  void MergeFrom(const Attotime& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 seconds = 1 [default = 0];
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::int32 seconds() const;
  inline void set_seconds(::google::protobuf::int32 value);
  
  // required int64 attoseconds = 2 [default = 0];
  inline bool has_attoseconds() const;
  inline void clear_attoseconds();
  static const int kAttosecondsFieldNumber = 2;
  inline ::google::protobuf::int64 attoseconds() const;
  inline void set_attoseconds(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:nsm.Attotime)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_attoseconds();
  inline void clear_has_attoseconds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 attoseconds_;
  ::google::protobuf::int32 seconds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static Attotime* default_instance_;
};
// -------------------------------------------------------------------

class AnalogPort : public ::google::protobuf::Message {
 public:
  AnalogPort();
  virtual ~AnalogPort();
  
  AnalogPort(const AnalogPort& from);
  
  inline AnalogPort& operator=(const AnalogPort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalogPort& default_instance();
  
  void Swap(AnalogPort* other);
  
  // implements Message ----------------------------------------------
  
  AnalogPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalogPort& from);
  void MergeFrom(const AnalogPort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 accum = 1;
  inline bool has_accum() const;
  inline void clear_accum();
  static const int kAccumFieldNumber = 1;
  inline ::google::protobuf::int32 accum() const;
  inline void set_accum(::google::protobuf::int32 value);
  
  // required int32 previous = 2;
  inline bool has_previous() const;
  inline void clear_previous();
  static const int kPreviousFieldNumber = 2;
  inline ::google::protobuf::int32 previous() const;
  inline void set_previous(::google::protobuf::int32 value);
  
  // required int32 sensitivity = 3;
  inline bool has_sensitivity() const;
  inline void clear_sensitivity();
  static const int kSensitivityFieldNumber = 3;
  inline ::google::protobuf::int32 sensitivity() const;
  inline void set_sensitivity(::google::protobuf::int32 value);
  
  // required bool reverse = 4;
  inline bool has_reverse() const;
  inline void clear_reverse();
  static const int kReverseFieldNumber = 4;
  inline bool reverse() const;
  inline void set_reverse(bool value);
  
  // @@protoc_insertion_point(class_scope:nsm.AnalogPort)
 private:
  inline void set_has_accum();
  inline void clear_has_accum();
  inline void set_has_previous();
  inline void clear_has_previous();
  inline void set_has_sensitivity();
  inline void clear_has_sensitivity();
  inline void set_has_reverse();
  inline void clear_has_reverse();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 accum_;
  ::google::protobuf::int32 previous_;
  ::google::protobuf::int32 sensitivity_;
  bool reverse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static AnalogPort* default_instance_;
};
// -------------------------------------------------------------------

class InputPort : public ::google::protobuf::Message {
 public:
  InputPort();
  virtual ~InputPort();
  
  InputPort(const InputPort& from);
  
  inline InputPort& operator=(const InputPort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputPort& default_instance();
  
  void Swap(InputPort* other);
  
  // implements Message ----------------------------------------------
  
  InputPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputPort& from);
  void MergeFrom(const InputPort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 defvalue = 1;
  inline bool has_defvalue() const;
  inline void clear_defvalue();
  static const int kDefvalueFieldNumber = 1;
  inline ::google::protobuf::uint32 defvalue() const;
  inline void set_defvalue(::google::protobuf::uint32 value);
  
  // required uint32 digital = 2;
  inline bool has_digital() const;
  inline void clear_digital();
  static const int kDigitalFieldNumber = 2;
  inline ::google::protobuf::uint32 digital() const;
  inline void set_digital(::google::protobuf::uint32 value);
  
  // repeated .nsm.AnalogPort analogPorts = 3;
  inline int analogports_size() const;
  inline void clear_analogports();
  static const int kAnalogPortsFieldNumber = 3;
  inline const ::nsm::AnalogPort& analogports(int index) const;
  inline ::nsm::AnalogPort* mutable_analogports(int index);
  inline ::nsm::AnalogPort* add_analogports();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >&
      analogports() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >*
      mutable_analogports();
  
  // @@protoc_insertion_point(class_scope:nsm.InputPort)
 private:
  inline void set_has_defvalue();
  inline void clear_has_defvalue();
  inline void set_has_digital();
  inline void clear_has_digital();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 defvalue_;
  ::google::protobuf::uint32 digital_;
  ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort > analogports_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static InputPort* default_instance_;
};
// -------------------------------------------------------------------

class InputState : public ::google::protobuf::Message {
 public:
  InputState();
  virtual ~InputState();
  
  InputState(const InputState& from);
  
  inline InputState& operator=(const InputState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputState& default_instance();
  
  void Swap(InputState* other);
  
  // implements Message ----------------------------------------------
  
  InputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputState& from);
  void MergeFrom(const InputState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .nsm.InputPort ports = 1;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 1;
  inline const ::nsm::InputPort& ports(int index) const;
  inline ::nsm::InputPort* mutable_ports(int index);
  inline ::nsm::InputPort* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >*
      mutable_ports();
  
  // repeated int32 players = 2 [packed = true];
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline ::google::protobuf::int32 players(int index) const;
  inline void set_players(int index, ::google::protobuf::int32 value);
  inline void add_players(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      players() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_players();
  
  // @@protoc_insertion_point(class_scope:nsm.InputState)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::nsm::InputPort > ports_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > players_;
  mutable int _players_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static InputState* default_instance_;
};
// -------------------------------------------------------------------

class PeerInputData : public ::google::protobuf::Message {
 public:
  PeerInputData();
  virtual ~PeerInputData();
  
  PeerInputData(const PeerInputData& from);
  
  inline PeerInputData& operator=(const PeerInputData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerInputData& default_instance();
  
  void Swap(PeerInputData* other);
  
  // implements Message ----------------------------------------------
  
  PeerInputData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerInputData& from);
  void MergeFrom(const PeerInputData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PeerInputData_PeerInputType PeerInputType;
  static const PeerInputType INPUT = PeerInputData_PeerInputType_INPUT;
  static const PeerInputType CHAT = PeerInputData_PeerInputType_CHAT;
  static const PeerInputType FORCE_VALUE = PeerInputData_PeerInputType_FORCE_VALUE;
  static inline bool PeerInputType_IsValid(int value) {
    return PeerInputData_PeerInputType_IsValid(value);
  }
  static const PeerInputType PeerInputType_MIN =
    PeerInputData_PeerInputType_PeerInputType_MIN;
  static const PeerInputType PeerInputType_MAX =
    PeerInputData_PeerInputType_PeerInputType_MAX;
  static const int PeerInputType_ARRAYSIZE =
    PeerInputData_PeerInputType_PeerInputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PeerInputType_descriptor() {
    return PeerInputData_PeerInputType_descriptor();
  }
  static inline const ::std::string& PeerInputType_Name(PeerInputType value) {
    return PeerInputData_PeerInputType_Name(value);
  }
  static inline bool PeerInputType_Parse(const ::std::string& name,
      PeerInputType* value) {
    return PeerInputData_PeerInputType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 counter = 1;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 1;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);
  
  // required .nsm.Attotime time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::nsm::Attotime& time() const;
  inline ::nsm::Attotime* mutable_time();
  inline ::nsm::Attotime* release_time();
  
  // required .nsm.PeerInputData.PeerInputType inputType = 3;
  inline bool has_inputtype() const;
  inline void clear_inputtype();
  static const int kInputTypeFieldNumber = 3;
  inline ::nsm::PeerInputData_PeerInputType inputtype() const;
  inline void set_inputtype(::nsm::PeerInputData_PeerInputType value);
  
  // optional .nsm.InputState inputState = 4;
  inline bool has_inputstate() const;
  inline void clear_inputstate();
  static const int kInputStateFieldNumber = 4;
  inline const ::nsm::InputState& inputstate() const;
  inline ::nsm::InputState* mutable_inputstate();
  inline ::nsm::InputState* release_inputstate();
  
  // optional bytes inputBuffer = 5;
  inline bool has_inputbuffer() const;
  inline void clear_inputbuffer();
  static const int kInputBufferFieldNumber = 5;
  inline const ::std::string& inputbuffer() const;
  inline void set_inputbuffer(const ::std::string& value);
  inline void set_inputbuffer(const char* value);
  inline void set_inputbuffer(const void* value, size_t size);
  inline ::std::string* mutable_inputbuffer();
  inline ::std::string* release_inputbuffer();
  
  // @@protoc_insertion_point(class_scope:nsm.PeerInputData)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_inputtype();
  inline void clear_has_inputtype();
  inline void set_has_inputstate();
  inline void clear_has_inputstate();
  inline void set_has_inputbuffer();
  inline void clear_has_inputbuffer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nsm::Attotime* time_;
  ::google::protobuf::int32 counter_;
  int inputtype_;
  ::nsm::InputState* inputstate_;
  ::std::string* inputbuffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static PeerInputData* default_instance_;
};
// -------------------------------------------------------------------

class PeerInputDataList : public ::google::protobuf::Message {
 public:
  PeerInputDataList();
  virtual ~PeerInputDataList();
  
  PeerInputDataList(const PeerInputDataList& from);
  
  inline PeerInputDataList& operator=(const PeerInputDataList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerInputDataList& default_instance();
  
  void Swap(PeerInputDataList* other);
  
  // implements Message ----------------------------------------------
  
  PeerInputDataList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerInputDataList& from);
  void MergeFrom(const PeerInputDataList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .nsm.PeerInputData input_data = 1;
  inline int input_data_size() const;
  inline void clear_input_data();
  static const int kInputDataFieldNumber = 1;
  inline const ::nsm::PeerInputData& input_data(int index) const;
  inline ::nsm::PeerInputData* mutable_input_data(int index);
  inline ::nsm::PeerInputData* add_input_data();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >&
      input_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >*
      mutable_input_data();
  
  // required int32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::int32 peer_id() const;
  inline void set_peer_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:nsm.PeerInputDataList)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData > input_data_;
  ::google::protobuf::int32 peer_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static PeerInputDataList* default_instance_;
};
// -------------------------------------------------------------------

class InitialSync : public ::google::protobuf::Message {
 public:
  InitialSync();
  virtual ~InitialSync();
  
  InitialSync(const InitialSync& from);
  
  inline InitialSync& operator=(const InitialSync& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitialSync& default_instance();
  
  void Swap(InitialSync* other);
  
  // implements Message ----------------------------------------------
  
  InitialSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitialSync& from);
  void MergeFrom(const InitialSync& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 checksum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 1;
  inline ::google::protobuf::uint32 checksum() const;
  inline void set_checksum(::google::protobuf::uint32 value);
  
  // repeated bytes initial_block = 2;
  inline int initial_block_size() const;
  inline void clear_initial_block();
  static const int kInitialBlockFieldNumber = 2;
  inline const ::std::string& initial_block(int index) const;
  inline ::std::string* mutable_initial_block(int index);
  inline void set_initial_block(int index, const ::std::string& value);
  inline void set_initial_block(int index, const char* value);
  inline void set_initial_block(int index, const void* value, size_t size);
  inline ::std::string* add_initial_block();
  inline void add_initial_block(const ::std::string& value);
  inline void add_initial_block(const char* value);
  inline void add_initial_block(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& initial_block() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_initial_block();
  
  // repeated .nsm.PeerInputDataList peer_data = 3;
  inline int peer_data_size() const;
  inline void clear_peer_data();
  static const int kPeerDataFieldNumber = 3;
  inline const ::nsm::PeerInputDataList& peer_data(int index) const;
  inline ::nsm::PeerInputDataList* mutable_peer_data(int index);
  inline ::nsm::PeerInputDataList* add_peer_data();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >&
      peer_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >*
      mutable_peer_data();
  
  // repeated bytes nvram = 4;
  inline int nvram_size() const;
  inline void clear_nvram();
  static const int kNvramFieldNumber = 4;
  inline const ::std::string& nvram(int index) const;
  inline ::std::string* mutable_nvram(int index);
  inline void set_nvram(int index, const ::std::string& value);
  inline void set_nvram(int index, const char* value);
  inline void set_nvram(int index, const void* value, size_t size);
  inline ::std::string* add_nvram();
  inline void add_nvram(const ::std::string& value);
  inline void add_nvram(const char* value);
  inline void add_nvram(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nvram() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nvram();
  
  // @@protoc_insertion_point(class_scope:nsm.InitialSync)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> initial_block_;
  ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList > peer_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nvram_;
  ::google::protobuf::uint32 checksum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();
  
  void InitAsDefaultInstance();
  static InitialSync* default_instance_;
};
// ===================================================================


// ===================================================================

// Attotime

// required int32 seconds = 1 [default = 0];
inline bool Attotime::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attotime::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attotime::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attotime::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 Attotime::seconds() const {
  return seconds_;
}
inline void Attotime::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
}

// required int64 attoseconds = 2 [default = 0];
inline bool Attotime::has_attoseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attotime::set_has_attoseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attotime::clear_has_attoseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attotime::clear_attoseconds() {
  attoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_attoseconds();
}
inline ::google::protobuf::int64 Attotime::attoseconds() const {
  return attoseconds_;
}
inline void Attotime::set_attoseconds(::google::protobuf::int64 value) {
  set_has_attoseconds();
  attoseconds_ = value;
}

// -------------------------------------------------------------------

// AnalogPort

// required int32 accum = 1;
inline bool AnalogPort::has_accum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalogPort::set_has_accum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalogPort::clear_has_accum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalogPort::clear_accum() {
  accum_ = 0;
  clear_has_accum();
}
inline ::google::protobuf::int32 AnalogPort::accum() const {
  return accum_;
}
inline void AnalogPort::set_accum(::google::protobuf::int32 value) {
  set_has_accum();
  accum_ = value;
}

// required int32 previous = 2;
inline bool AnalogPort::has_previous() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalogPort::set_has_previous() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalogPort::clear_has_previous() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalogPort::clear_previous() {
  previous_ = 0;
  clear_has_previous();
}
inline ::google::protobuf::int32 AnalogPort::previous() const {
  return previous_;
}
inline void AnalogPort::set_previous(::google::protobuf::int32 value) {
  set_has_previous();
  previous_ = value;
}

// required int32 sensitivity = 3;
inline bool AnalogPort::has_sensitivity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalogPort::set_has_sensitivity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalogPort::clear_has_sensitivity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalogPort::clear_sensitivity() {
  sensitivity_ = 0;
  clear_has_sensitivity();
}
inline ::google::protobuf::int32 AnalogPort::sensitivity() const {
  return sensitivity_;
}
inline void AnalogPort::set_sensitivity(::google::protobuf::int32 value) {
  set_has_sensitivity();
  sensitivity_ = value;
}

// required bool reverse = 4;
inline bool AnalogPort::has_reverse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalogPort::set_has_reverse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalogPort::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalogPort::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
inline bool AnalogPort::reverse() const {
  return reverse_;
}
inline void AnalogPort::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
}

// -------------------------------------------------------------------

// InputPort

// required uint32 defvalue = 1;
inline bool InputPort::has_defvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputPort::set_has_defvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputPort::clear_has_defvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputPort::clear_defvalue() {
  defvalue_ = 0u;
  clear_has_defvalue();
}
inline ::google::protobuf::uint32 InputPort::defvalue() const {
  return defvalue_;
}
inline void InputPort::set_defvalue(::google::protobuf::uint32 value) {
  set_has_defvalue();
  defvalue_ = value;
}

// required uint32 digital = 2;
inline bool InputPort::has_digital() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputPort::set_has_digital() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputPort::clear_has_digital() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputPort::clear_digital() {
  digital_ = 0u;
  clear_has_digital();
}
inline ::google::protobuf::uint32 InputPort::digital() const {
  return digital_;
}
inline void InputPort::set_digital(::google::protobuf::uint32 value) {
  set_has_digital();
  digital_ = value;
}

// repeated .nsm.AnalogPort analogPorts = 3;
inline int InputPort::analogports_size() const {
  return analogports_.size();
}
inline void InputPort::clear_analogports() {
  analogports_.Clear();
}
inline const ::nsm::AnalogPort& InputPort::analogports(int index) const {
  return analogports_.Get(index);
}
inline ::nsm::AnalogPort* InputPort::mutable_analogports(int index) {
  return analogports_.Mutable(index);
}
inline ::nsm::AnalogPort* InputPort::add_analogports() {
  return analogports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >&
InputPort::analogports() const {
  return analogports_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >*
InputPort::mutable_analogports() {
  return &analogports_;
}

// -------------------------------------------------------------------

// InputState

// repeated .nsm.InputPort ports = 1;
inline int InputState::ports_size() const {
  return ports_.size();
}
inline void InputState::clear_ports() {
  ports_.Clear();
}
inline const ::nsm::InputPort& InputState::ports(int index) const {
  return ports_.Get(index);
}
inline ::nsm::InputPort* InputState::mutable_ports(int index) {
  return ports_.Mutable(index);
}
inline ::nsm::InputPort* InputState::add_ports() {
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >&
InputState::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >*
InputState::mutable_ports() {
  return &ports_;
}

// repeated int32 players = 2 [packed = true];
inline int InputState::players_size() const {
  return players_.size();
}
inline void InputState::clear_players() {
  players_.Clear();
}
inline ::google::protobuf::int32 InputState::players(int index) const {
  return players_.Get(index);
}
inline void InputState::set_players(int index, ::google::protobuf::int32 value) {
  players_.Set(index, value);
}
inline void InputState::add_players(::google::protobuf::int32 value) {
  players_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InputState::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InputState::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// PeerInputData

// required int32 counter = 1;
inline bool PeerInputData::has_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerInputData::set_has_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerInputData::clear_has_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerInputData::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 PeerInputData::counter() const {
  return counter_;
}
inline void PeerInputData::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
}

// required .nsm.Attotime time = 2;
inline bool PeerInputData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerInputData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerInputData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerInputData::clear_time() {
  if (time_ != NULL) time_->::nsm::Attotime::Clear();
  clear_has_time();
}
inline const ::nsm::Attotime& PeerInputData::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::nsm::Attotime* PeerInputData::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::nsm::Attotime;
  return time_;
}
inline ::nsm::Attotime* PeerInputData::release_time() {
  clear_has_time();
  ::nsm::Attotime* temp = time_;
  time_ = NULL;
  return temp;
}

// required .nsm.PeerInputData.PeerInputType inputType = 3;
inline bool PeerInputData::has_inputtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeerInputData::set_has_inputtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeerInputData::clear_has_inputtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeerInputData::clear_inputtype() {
  inputtype_ = 0;
  clear_has_inputtype();
}
inline ::nsm::PeerInputData_PeerInputType PeerInputData::inputtype() const {
  return static_cast< ::nsm::PeerInputData_PeerInputType >(inputtype_);
}
inline void PeerInputData::set_inputtype(::nsm::PeerInputData_PeerInputType value) {
  GOOGLE_DCHECK(::nsm::PeerInputData_PeerInputType_IsValid(value));
  set_has_inputtype();
  inputtype_ = value;
}

// optional .nsm.InputState inputState = 4;
inline bool PeerInputData::has_inputstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PeerInputData::set_has_inputstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PeerInputData::clear_has_inputstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PeerInputData::clear_inputstate() {
  if (inputstate_ != NULL) inputstate_->::nsm::InputState::Clear();
  clear_has_inputstate();
}
inline const ::nsm::InputState& PeerInputData::inputstate() const {
  return inputstate_ != NULL ? *inputstate_ : *default_instance_->inputstate_;
}
inline ::nsm::InputState* PeerInputData::mutable_inputstate() {
  set_has_inputstate();
  if (inputstate_ == NULL) inputstate_ = new ::nsm::InputState;
  return inputstate_;
}
inline ::nsm::InputState* PeerInputData::release_inputstate() {
  clear_has_inputstate();
  ::nsm::InputState* temp = inputstate_;
  inputstate_ = NULL;
  return temp;
}

// optional bytes inputBuffer = 5;
inline bool PeerInputData::has_inputbuffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PeerInputData::set_has_inputbuffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PeerInputData::clear_has_inputbuffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PeerInputData::clear_inputbuffer() {
  if (inputbuffer_ != &::google::protobuf::internal::kEmptyString) {
    inputbuffer_->clear();
  }
  clear_has_inputbuffer();
}
inline const ::std::string& PeerInputData::inputbuffer() const {
  return *inputbuffer_;
}
inline void PeerInputData::set_inputbuffer(const ::std::string& value) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::kEmptyString) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(value);
}
inline void PeerInputData::set_inputbuffer(const char* value) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::kEmptyString) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(value);
}
inline void PeerInputData::set_inputbuffer(const void* value, size_t size) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::kEmptyString) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PeerInputData::mutable_inputbuffer() {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::kEmptyString) {
    inputbuffer_ = new ::std::string;
  }
  return inputbuffer_;
}
inline ::std::string* PeerInputData::release_inputbuffer() {
  clear_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputbuffer_;
    inputbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PeerInputDataList

// repeated .nsm.PeerInputData input_data = 1;
inline int PeerInputDataList::input_data_size() const {
  return input_data_.size();
}
inline void PeerInputDataList::clear_input_data() {
  input_data_.Clear();
}
inline const ::nsm::PeerInputData& PeerInputDataList::input_data(int index) const {
  return input_data_.Get(index);
}
inline ::nsm::PeerInputData* PeerInputDataList::mutable_input_data(int index) {
  return input_data_.Mutable(index);
}
inline ::nsm::PeerInputData* PeerInputDataList::add_input_data() {
  return input_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >&
PeerInputDataList::input_data() const {
  return input_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >*
PeerInputDataList::mutable_input_data() {
  return &input_data_;
}

// required int32 peer_id = 2;
inline bool PeerInputDataList::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerInputDataList::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerInputDataList::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerInputDataList::clear_peer_id() {
  peer_id_ = 0;
  clear_has_peer_id();
}
inline ::google::protobuf::int32 PeerInputDataList::peer_id() const {
  return peer_id_;
}
inline void PeerInputDataList::set_peer_id(::google::protobuf::int32 value) {
  set_has_peer_id();
  peer_id_ = value;
}

// -------------------------------------------------------------------

// InitialSync

// optional uint32 checksum = 1;
inline bool InitialSync::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitialSync::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitialSync::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitialSync::clear_checksum() {
  checksum_ = 0u;
  clear_has_checksum();
}
inline ::google::protobuf::uint32 InitialSync::checksum() const {
  return checksum_;
}
inline void InitialSync::set_checksum(::google::protobuf::uint32 value) {
  set_has_checksum();
  checksum_ = value;
}

// repeated bytes initial_block = 2;
inline int InitialSync::initial_block_size() const {
  return initial_block_.size();
}
inline void InitialSync::clear_initial_block() {
  initial_block_.Clear();
}
inline const ::std::string& InitialSync::initial_block(int index) const {
  return initial_block_.Get(index);
}
inline ::std::string* InitialSync::mutable_initial_block(int index) {
  return initial_block_.Mutable(index);
}
inline void InitialSync::set_initial_block(int index, const ::std::string& value) {
  initial_block_.Mutable(index)->assign(value);
}
inline void InitialSync::set_initial_block(int index, const char* value) {
  initial_block_.Mutable(index)->assign(value);
}
inline void InitialSync::set_initial_block(int index, const void* value, size_t size) {
  initial_block_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitialSync::add_initial_block() {
  return initial_block_.Add();
}
inline void InitialSync::add_initial_block(const ::std::string& value) {
  initial_block_.Add()->assign(value);
}
inline void InitialSync::add_initial_block(const char* value) {
  initial_block_.Add()->assign(value);
}
inline void InitialSync::add_initial_block(const void* value, size_t size) {
  initial_block_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InitialSync::initial_block() const {
  return initial_block_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InitialSync::mutable_initial_block() {
  return &initial_block_;
}

// repeated .nsm.PeerInputDataList peer_data = 3;
inline int InitialSync::peer_data_size() const {
  return peer_data_.size();
}
inline void InitialSync::clear_peer_data() {
  peer_data_.Clear();
}
inline const ::nsm::PeerInputDataList& InitialSync::peer_data(int index) const {
  return peer_data_.Get(index);
}
inline ::nsm::PeerInputDataList* InitialSync::mutable_peer_data(int index) {
  return peer_data_.Mutable(index);
}
inline ::nsm::PeerInputDataList* InitialSync::add_peer_data() {
  return peer_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >&
InitialSync::peer_data() const {
  return peer_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >*
InitialSync::mutable_peer_data() {
  return &peer_data_;
}

// repeated bytes nvram = 4;
inline int InitialSync::nvram_size() const {
  return nvram_.size();
}
inline void InitialSync::clear_nvram() {
  nvram_.Clear();
}
inline const ::std::string& InitialSync::nvram(int index) const {
  return nvram_.Get(index);
}
inline ::std::string* InitialSync::mutable_nvram(int index) {
  return nvram_.Mutable(index);
}
inline void InitialSync::set_nvram(int index, const ::std::string& value) {
  nvram_.Mutable(index)->assign(value);
}
inline void InitialSync::set_nvram(int index, const char* value) {
  nvram_.Mutable(index)->assign(value);
}
inline void InitialSync::set_nvram(int index, const void* value, size_t size) {
  nvram_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitialSync::add_nvram() {
  return nvram_.Add();
}
inline void InitialSync::add_nvram(const ::std::string& value) {
  nvram_.Add()->assign(value);
}
inline void InitialSync::add_nvram(const char* value) {
  nvram_.Add()->assign(value);
}
inline void InitialSync::add_nvram(const void* value, size_t size) {
  nvram_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InitialSync::nvram() const {
  return nvram_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InitialSync::mutable_nvram() {
  return &nvram_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsm::PeerInputData_PeerInputType>() {
  return ::nsm::PeerInputData_PeerInputType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nsm_2eproto__INCLUDED
